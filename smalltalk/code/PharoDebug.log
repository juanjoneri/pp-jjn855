THERE_BE_DRAGONS_HERE
Instance of ZnCharacterWriteStream did not understand #splitOn:
22 October 2021 3:35:01.307276 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
v9.0.9 - Commit: 220ee65 - Date: 2021-10-11 15:53:10 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1564.sha.f5f541cb35c8609abfec418e35d5506715c7987d (64 Bit)]

ZnCharacterWriteStream(Object)>>doesNotUnderstand: #splitOn:
	Receiver: a ZnCharacterWriteStream
	Arguments and temporary variables: 
		aMessage: 	splitOn: ' '
		exception: 	Instance of ZnCharacterWriteStream did not understand #splitOn:
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a ZnBufferedWriteStream
		encoder: 	a ZnUTF8Encoder


TableMain>>main:
	Receiver: a TableMain
	Arguments and temporary variables: 
		message: 	'-print 0 ../tests/1.txt ../tests/1.out'
		working: 	File @ /home/juanjoneri/UT/AdvancedAlgorithms/pp-jjn855/smalltalk/code...etc...
		stream: 	a ZnCharacterWriteStream
		args: 	nil
	Receiver's instance variables: 
a TableMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		a: 	a TableMain
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


OpalCompiler>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../test...etc...
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/1.o...etc...
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	a CompiledBlock: [ 
	result := Smalltalk compiler evaluate: aStream.
	...etc...
		numArgs: 	0
		receiver: 	an EvaluateCommandLineHandler


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/1.o...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../te...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImportCommandLineHandlers-Base'


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
		^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	a CompiledBlock: [ aCommandLinehandler activateWith: commandLine ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self handleArgument: self firstArgument ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | 
			"If the command line is protected by password, we ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ ...etc...
		startpc: 	a CompiledBlock: [ self handleArgument: self firstArgument ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the comma...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	a CompiledBlock: [ [ self handleArgument: self firstArgument ]
		on: E...etc...
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler



--- The full stack ---
ZnCharacterWriteStream(Object)>>doesNotUnderstand: #splitOn:
TableMain>>main:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
FullBlockClosure(BlockClosure)>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
FullBlockClosure(BlockClosure)>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
FullBlockClosure(BlockClosure)>>on:do:
[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
Processor in InputEventFetcher>>installEventLoop
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
TKTWorkerProcess>>privateNextTask
workerLoop

	[ self executeTask: self privateNextTask ] repeat in TKTWorkerProcess>>workerLoop
BlockClosure>>repeat
TKTWorkerProcess>>workerLoop
MessageSend>>value
arg1 in TKTPharoProcessProvider>>createProcessDoing:named:
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[  [runTimerEventLoop] whileTrue: 
		[	|nowTick|
			"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		 	ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay. 

			"Invoke the api back-ends, which set the transfer-variable to nil" 		
			suspendSemaphore ifNotNil: [ self suspendAtTimingPriority    ].
			delayToStart     ifNotNil: [ self scheduleAtTimingPriority   ].
			delayToStop      ifNotNil: [ self unscheduleAtTimingPriority ].

			"Signal any expired delays"
			nowTick := ticker nowTick.
			[ 	activeDelay notNil and: [nowTick >= activeDelay resumptionTick] ] 
					whileTrue: [
						activeDelay timingPrioritySignalExpired.
						activeDelay := suspendedDelays removeFirstOrNil ].
		]
	] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
FullBlockClosure(BlockClosure)>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
  stack:

[
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]] in CommandLineUIManager>>quitFrom:withMessage:
[
		logStream := self openLog.
		aMonadicBlock value: logStream.
	] in SmalltalkImage>>logDuring:
FullBlockClosure(BlockClosure)>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk 
		logError: aString
		inContext: aContext.
		
	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
FullBlockClosure(BlockClosure)>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
MessageNotUnderstood(Exception)>>unhandledErrorAction
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Exception)>>raiseUnhandledError
MessageNotUnderstood(Exception)>>defaultAction
------------------------------

THERE_BE_DRAGONS_HERE
Instance of ZnCharacterReadStream did not understand #do:
22 October 2021 5:03:12.35048 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
v9.0.9 - Commit: 220ee65 - Date: 2021-10-11 15:53:10 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1564.sha.f5f541cb35c8609abfec418e35d5506715c7987d (64 Bit)]

ZnCharacterReadStream(Object)>>doesNotUnderstand: #do:
	Receiver: a ZnCharacterReadStream
	Arguments and temporary variables: 
		aMessage: 	do: [ :in | (table add: in) ]
		exception: 	Instance of ZnCharacterReadStream did not understand #do:
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a ZnBufferedReadStream
		encoder: 	a ZnUTF8Encoder
		peeked: 	nil


Program>>readTable
	Receiver: a Program
	Arguments and temporary variables: 
		working: 	File @ /home/juanjoneri/UT/AdvancedAlgorithms/pp-jjn855/smalltalk/code...etc...
		stream: 	a ZnCharacterReadStream
		table: 	a LinkedList()
	Receiver's instance variables: 
		operation: 	'-print'
		argument: 	'0'
		tableFile: 	'../tests/1.txt'
		outFile: 	'../tests/0.out'


TableMain>>main:
	Receiver: a TableMain
	Arguments and temporary variables: 
		message: 	'-print 0 ../tests/1.txt ../tests/0.out'
		program: 	a Program
		table: 	nil
	Receiver's instance variables: 
a TableMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		a: 	a TableMain
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


OpalCompiler>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../test...etc...
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	a CompiledBlock: [ 
	result := Smalltalk compiler evaluate: aStream.
	...etc...
		numArgs: 	0
		receiver: 	an EvaluateCommandLineHandler


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../te...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImportCommandLineHandlers-Base'


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
		^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	a CompiledBlock: [ aCommandLinehandler activateWith: commandLine ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self handleArgument: self firstArgument ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | 
			"If the command line is protected by password, we ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ ...etc...
		startpc: 	a CompiledBlock: [ self handleArgument: self firstArgument ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the comma...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	a CompiledBlock: [ [ self handleArgument: self firstArgument ]
		on: E...etc...
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler



--- The full stack ---
ZnCharacterReadStream(Object)>>doesNotUnderstand: #do:
Program>>readTable
TableMain>>main:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
FullBlockClosure(BlockClosure)>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
FullBlockClosure(BlockClosure)>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
FullBlockClosure(BlockClosure)>>on:do:
[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
Processor in InputEventFetcher>>installEventLoop
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
TKTWorkerProcess>>privateNextTask
workerLoop

	[ self executeTask: self privateNextTask ] repeat in TKTWorkerProcess>>workerLoop
BlockClosure>>repeat
TKTWorkerProcess>>workerLoop
MessageSend>>value
arg1 in TKTPharoProcessProvider>>createProcessDoing:named:
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[  [runTimerEventLoop] whileTrue: 
		[	|nowTick|
			"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		 	ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay. 

			"Invoke the api back-ends, which set the transfer-variable to nil" 		
			suspendSemaphore ifNotNil: [ self suspendAtTimingPriority    ].
			delayToStart     ifNotNil: [ self scheduleAtTimingPriority   ].
			delayToStop      ifNotNil: [ self unscheduleAtTimingPriority ].

			"Signal any expired delays"
			nowTick := ticker nowTick.
			[ 	activeDelay notNil and: [nowTick >= activeDelay resumptionTick] ] 
					whileTrue: [
						activeDelay timingPrioritySignalExpired.
						activeDelay := suspendedDelays removeFirstOrNil ].
		]
	] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
FullBlockClosure(BlockClosure)>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
  stack:

[
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]] in CommandLineUIManager>>quitFrom:withMessage:
[
		logStream := self openLog.
		aMonadicBlock value: logStream.
	] in SmalltalkImage>>logDuring:
FullBlockClosure(BlockClosure)>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk 
		logError: aString
		inContext: aContext.
		
	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
FullBlockClosure(BlockClosure)>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
MessageNotUnderstood(Exception)>>unhandledErrorAction
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Exception)>>raiseUnhandledError
MessageNotUnderstood(Exception)>>defaultAction
------------------------------

THERE_BE_DRAGONS_HERE
Instance of LinkedList did not understand #isByteString
22 October 2021 5:05:33.850515 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
v9.0.9 - Commit: 220ee65 - Date: 2021-10-11 15:53:10 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1564.sha.f5f541cb35c8609abfec418e35d5506715c7987d (64 Bit)]

LinkedList(Object)>>doesNotUnderstand: #isByteString
	Receiver: a LinkedList(a ZnCharacterReadStream)
	Arguments and temporary variables: 
		aMessage: 	isByteString
		exception: 	Instance of LinkedList did not understand #isByteString
		resumeValue: 	nil
	Receiver's instance variables: 
		firstLink: 	ValueLink(a ZnCharacterReadStream)
		lastLink: 	ValueLink(a ZnCharacterReadStream)


ZnUTF8Encoder>>next:putAll:startingAt:toStream:
	Receiver: a ZnUTF8Encoder
	Arguments and temporary variables: 
		count: 	1
		string: 	a LinkedList(a ZnCharacterReadStream)
		offset: 	1
		stream: 	a ZnBufferedWriteStream
	Receiver's instance variables: 
a ZnUTF8Encoder

ZnCharacterWriteStream>>next:putAll:startingAt:
	Receiver: a ZnCharacterWriteStream
	Arguments and temporary variables: 
		count: 	1
		collection: 	a LinkedList(a ZnCharacterReadStream)
		offset: 	1
	Receiver's instance variables: 
		stream: 	a ZnBufferedWriteStream
		encoder: 	a ZnUTF8Encoder


ZnCharacterWriteStream(ZnEncodedWriteStream)>>nextPutAll:
	Receiver: a ZnCharacterWriteStream
	Arguments and temporary variables: 
		collection: 	a LinkedList(a ZnCharacterReadStream)
	Receiver's instance variables: 
		stream: 	a ZnBufferedWriteStream
		encoder: 	a ZnUTF8Encoder


Program>>writeTable:
	Receiver: a Program
	Arguments and temporary variables: 
		value: 	a LinkedList(a ZnCharacterReadStream)
		working: 	File @ /home/juanjoneri/UT/AdvancedAlgorithms/pp-jjn855/smalltalk/code...etc...
		stream: 	a ZnCharacterWriteStream
	Receiver's instance variables: 
		operation: 	'-print'
		argument: 	'0'
		tableFile: 	'../tests/1.txt'
		outFile: 	'../tests/0.out'


TableMain>>main:
	Receiver: a TableMain
	Arguments and temporary variables: 
		message: 	'-print 0 ../tests/1.txt ../tests/0.out'
		program: 	a Program
		table: 	a LinkedList(a ZnCharacterReadStream)
	Receiver's instance variables: 
a TableMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		a: 	a TableMain
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


OpalCompiler>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../test...etc...
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	a CompiledBlock: [ 
	result := Smalltalk compiler evaluate: aStream.
	...etc...
		numArgs: 	0
		receiver: 	an EvaluateCommandLineHandler


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../te...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImportCommandLineHandlers-Base'


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
		^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	a CompiledBlock: [ aCommandLinehandler activateWith: commandLine ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self handleArgument: self firstArgument ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | 
			"If the command line is protected by password, we ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ ...etc...
		startpc: 	a CompiledBlock: [ self handleArgument: self firstArgument ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the comma...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	a CompiledBlock: [ [ self handleArgument: self firstArgument ]
		on: E...etc...
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler



--- The full stack ---
LinkedList(Object)>>doesNotUnderstand: #isByteString
ZnUTF8Encoder>>next:putAll:startingAt:toStream:
ZnCharacterWriteStream>>next:putAll:startingAt:
ZnCharacterWriteStream(ZnEncodedWriteStream)>>nextPutAll:
Program>>writeTable:
TableMain>>main:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
FullBlockClosure(BlockClosure)>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
FullBlockClosure(BlockClosure)>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
FullBlockClosure(BlockClosure)>>on:do:
[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
Processor in InputEventFetcher>>installEventLoop
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
TKTWorkerProcess>>privateNextTask
workerLoop

	[ self executeTask: self privateNextTask ] repeat in TKTWorkerProcess>>workerLoop
BlockClosure>>repeat
TKTWorkerProcess>>workerLoop
MessageSend>>value
arg1 in TKTPharoProcessProvider>>createProcessDoing:named:
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in MorphicRenderLoop>>doOneCycleWhile:
  stack:

MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[  [runTimerEventLoop] whileTrue: 
		[	|nowTick|
			"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		 	ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay. 

			"Invoke the api back-ends, which set the transfer-variable to nil" 		
			suspendSemaphore ifNotNil: [ self suspendAtTimingPriority    ].
			delayToStart     ifNotNil: [ self scheduleAtTimingPriority   ].
			delayToStop      ifNotNil: [ self unscheduleAtTimingPriority ].

			"Signal any expired delays"
			nowTick := ticker nowTick.
			[ 	activeDelay notNil and: [nowTick >= activeDelay resumptionTick] ] 
					whileTrue: [
						activeDelay timingPrioritySignalExpired.
						activeDelay := suspendedDelays removeFirstOrNil ].
		]
	] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
FullBlockClosure(BlockClosure)>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
  stack:

[
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]] in CommandLineUIManager>>quitFrom:withMessage:
[
		logStream := self openLog.
		aMonadicBlock value: logStream.
	] in SmalltalkImage>>logDuring:
FullBlockClosure(BlockClosure)>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk 
		logError: aString
		inContext: aContext.
		
	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
FullBlockClosure(BlockClosure)>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
MessageNotUnderstood(Exception)>>unhandledErrorAction
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Exception)>>raiseUnhandledError
MessageNotUnderstood(Exception)>>defaultAction
------------------------------

THERE_BE_DRAGONS_HERE
PrimitiveFailed: primitive #sizeOf: in File class failed
22 October 2021 5:09:15.828905 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
v9.0.9 - Commit: 220ee65 - Date: 2021-10-11 15:53:10 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1564.sha.f5f541cb35c8609abfec418e35d5506715c7987d (64 Bit)]

File class(ProtoObject)>>primitiveFailed:
	Receiver: File
	Arguments and temporary variables: 
		selector: 	#sizeOf:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#basename->File>>#basename #basicOpenForWrite:->...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#File
		classPool: 	a Dictionary(#Registry->a WeakRegistry(<this WeakRegistry is locked>...etc...
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Core'


File class(ProtoObject)>>primitiveFailed
	Receiver: File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#basename->File>>#basename #basicOpenForWrite:->...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#File
		classPool: 	a Dictionary(#Registry->a WeakRegistry(<this WeakRegistry is locked>...etc...
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Core'


File class>>sizeOf:
	Receiver: File
	Arguments and temporary variables: 
		id: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#basename->File>>#basename #basicOpenForWrite:->...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#File
		classPool: 	a Dictionary(#Registry->a WeakRegistry(<this WeakRegistry is locked>...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Files-Core'


BinaryFileStream(AbstractBinaryFileStream)>>size
	Receiver: BinaryFileStream: '/home/juanjoneri/UT/AdvancedAlgorithms/pp-jjn855/smalltalk/code/../test...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		file: 	a File
		handle: 	nil
		forWrite: 	false
		semaphore: 	nil
		semaphoreIndex: 	nil


ZnBufferedReadStream>>size
	Receiver: a ZnBufferedReadStream
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		stream: 	BinaryFileStream: '/home/juanjoneri/UT/AdvancedAlgorithms/pp-jjn855/sma...etc...
		buffer: 	#[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0...etc...
		position: 	1
		limit: 	0


ZnCharacterReadStream(ZnEncodedStream)>>size
	Receiver: a ZnCharacterReadStream
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		stream: 	a ZnBufferedReadStream
		encoder: 	a ZnUTF8Encoder
		peeked: 	nil


ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	a ZnCharacterReadStream
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	a ZnCharacterReadStream
	Receiver's instance variables: 
''

[:each | tableName := tableName , each, '---'] in TableMain>>main:
	Receiver: a TableMain
	Arguments and temporary variables: 
		message: 	'-print 0 ../tests/1.txt ../tests/0.out'
		program: 	a Program
		table: 	a LinkedList(a ZnCharacterReadStream)
		tableName: 	''
		each: 	a ZnCharacterReadStream
	Receiver's instance variables: 
a TableMain

LinkedList>>do:
	Receiver: a LinkedList(a ZnCharacterReadStream)
	Arguments and temporary variables: 
		aBlock: 	[:each | tableName := tableName , each, '---']
		aLink: 	ValueLink(a ZnCharacterReadStream)
	Receiver's instance variables: 
		firstLink: 	ValueLink(a ZnCharacterReadStream)
		lastLink: 	ValueLink(a ZnCharacterReadStream)


TableMain>>main:
	Receiver: a TableMain
	Arguments and temporary variables: 
		tableName: 	''
		message: 	'-print 0 ../tests/1.txt ../tests/0.out'
		program: 	a Program
		table: 	a LinkedList(a ZnCharacterReadStream)
	Receiver's instance variables: 
a TableMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		a: 	a TableMain
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


OpalCompiler>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../test...etc...
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	a CompiledBlock: [ 
	result := Smalltalk compiler evaluate: aStream.
	...etc...
		numArgs: 	0
		receiver: 	an EvaluateCommandLineHandler


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../te...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImportCommandLineHandlers-Base'


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
		^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	a CompiledBlock: [ aCommandLinehandler activateWith: commandLine ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self handleArgument: self firstArgument ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | 
			"If the command line is protected by password, we ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ ...etc...
		startpc: 	a CompiledBlock: [ self handleArgument: self firstArgument ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the comma...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	a CompiledBlock: [ [ self handleArgument: self firstArgument ]
		on: E...etc...
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler



--- The full stack ---
File class(ProtoObject)>>primitiveFailed:
File class(ProtoObject)>>primitiveFailed
File class>>sizeOf:
BinaryFileStream(AbstractBinaryFileStream)>>size
ZnBufferedReadStream>>size
ZnCharacterReadStream(ZnEncodedStream)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:each | tableName := tableName , each, '---'] in TableMain>>main:
LinkedList>>do:
TableMain>>main:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
FullBlockClosure(BlockClosure)>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
FullBlockClosure(BlockClosure)>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
FullBlockClosure(BlockClosure)>>on:do:
[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
Processor in InputEventFetcher>>installEventLoop
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
TKTWorkerProcess>>privateNextTask
workerLoop

	[ self executeTask: self privateNextTask ] repeat in TKTWorkerProcess>>workerLoop
BlockClosure>>repeat
TKTWorkerProcess>>workerLoop
MessageSend>>value
arg1 in TKTPharoProcessProvider>>createProcessDoing:named:
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in MorphicRenderLoop>>doOneCycleWhile:
  stack:

MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[  [runTimerEventLoop] whileTrue: 
		[	|nowTick|
			"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		 	ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay. 

			"Invoke the api back-ends, which set the transfer-variable to nil" 		
			suspendSemaphore ifNotNil: [ self suspendAtTimingPriority    ].
			delayToStart     ifNotNil: [ self scheduleAtTimingPriority   ].
			delayToStop      ifNotNil: [ self unscheduleAtTimingPriority ].

			"Signal any expired delays"
			nowTick := ticker nowTick.
			[ 	activeDelay notNil and: [nowTick >= activeDelay resumptionTick] ] 
					whileTrue: [
						activeDelay timingPrioritySignalExpired.
						activeDelay := suspendedDelays removeFirstOrNil ].
		]
	] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
FullBlockClosure(BlockClosure)>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]] in CommandLineUIManager>>quitFrom:withMessage:
[
		logStream := self openLog.
		aMonadicBlock value: logStream.
	] in SmalltalkImage>>logDuring:
FullBlockClosure(BlockClosure)>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk 
		logError: aString
		inContext: aContext.
		
	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
FullBlockClosure(BlockClosure)>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
PrimitiveFailed(Exception)>>unhandledErrorAction
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
PrimitiveFailed(Exception)>>raiseUnhandledError
PrimitiveFailed(Exception)>>defaultAction
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in [
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
  stack:

[
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

THERE_BE_DRAGONS_HERE
Instance of ZnCharacterReadStream did not understand #do:
22 October 2021 5:22:38.45602 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
v9.0.9 - Commit: 220ee65 - Date: 2021-10-11 15:53:10 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1564.sha.f5f541cb35c8609abfec418e35d5506715c7987d (64 Bit)]

ZnCharacterReadStream(Object)>>doesNotUnderstand: #do:
	Receiver: a ZnCharacterReadStream
	Arguments and temporary variables: 
		aMessage: 	do: [ :each | table := table, each nextLine ]
		exception: 	Instance of ZnCharacterReadStream did not understand #do:
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a ZnBufferedReadStream
		encoder: 	a ZnUTF8Encoder
		peeked: 	nil


Program>>readTable
	Receiver: a Program
	Arguments and temporary variables: 
		table: 	''
		working: 	File @ /home/juanjoneri/UT/AdvancedAlgorithms/pp-jjn855/smalltalk/code...etc...
		stream: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		operation: 	'-print'
		argument: 	'0'
		tableFile: 	'../tests/1.txt'
		outFile: 	'../tests/0.out'


TableMain>>main:
	Receiver: a TableMain
	Arguments and temporary variables: 
		message: 	'-print 0 ../tests/1.txt ../tests/0.out'
		program: 	a Program
		table: 	nil
		tableName: 	nil
	Receiver's instance variables: 
a TableMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		a: 	a TableMain
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


OpalCompiler>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../test...etc...
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	a CompiledBlock: [ 
	result := Smalltalk compiler evaluate: aStream.
	...etc...
		numArgs: 	0
		receiver: 	an EvaluateCommandLineHandler


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../te...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImportCommandLineHandlers-Base'


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
		^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	a CompiledBlock: [ aCommandLinehandler activateWith: commandLine ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self handleArgument: self firstArgument ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | 
			"If the command line is protected by password, we ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ ...etc...
		startpc: 	a CompiledBlock: [ self handleArgument: self firstArgument ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the comma...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	a CompiledBlock: [ [ self handleArgument: self firstArgument ]
		on: E...etc...
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler



--- The full stack ---
ZnCharacterReadStream(Object)>>doesNotUnderstand: #do:
Program>>readTable
TableMain>>main:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
FullBlockClosure(BlockClosure)>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
FullBlockClosure(BlockClosure)>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
FullBlockClosure(BlockClosure)>>on:do:
[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
Processor in InputEventFetcher>>installEventLoop
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
TKTWorkerProcess>>privateNextTask
workerLoop

	[ self executeTask: self privateNextTask ] repeat in TKTWorkerProcess>>workerLoop
BlockClosure>>repeat
TKTWorkerProcess>>workerLoop
MessageSend>>value
arg1 in TKTPharoProcessProvider>>createProcessDoing:named:
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[  [runTimerEventLoop] whileTrue: 
		[	|nowTick|
			"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		 	ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay. 

			"Invoke the api back-ends, which set the transfer-variable to nil" 		
			suspendSemaphore ifNotNil: [ self suspendAtTimingPriority    ].
			delayToStart     ifNotNil: [ self scheduleAtTimingPriority   ].
			delayToStop      ifNotNil: [ self unscheduleAtTimingPriority ].

			"Signal any expired delays"
			nowTick := ticker nowTick.
			[ 	activeDelay notNil and: [nowTick >= activeDelay resumptionTick] ] 
					whileTrue: [
						activeDelay timingPrioritySignalExpired.
						activeDelay := suspendedDelays removeFirstOrNil ].
		]
	] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
FullBlockClosure(BlockClosure)>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
  stack:

[
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]] in CommandLineUIManager>>quitFrom:withMessage:
[
		logStream := self openLog.
		aMonadicBlock value: logStream.
	] in SmalltalkImage>>logDuring:
FullBlockClosure(BlockClosure)>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk 
		logError: aString
		inContext: aContext.
		
	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
FullBlockClosure(BlockClosure)>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
MessageNotUnderstood(Exception)>>unhandledErrorAction
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Exception)>>raiseUnhandledError
MessageNotUnderstood(Exception)>>defaultAction
------------------------------

THERE_BE_DRAGONS_HERE
Instance of ZnCharacterReadStream did not understand #do:
22 October 2021 5:22:56.909094 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
v9.0.9 - Commit: 220ee65 - Date: 2021-10-11 15:53:10 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1564.sha.f5f541cb35c8609abfec418e35d5506715c7987d (64 Bit)]

ZnCharacterReadStream(Object)>>doesNotUnderstand: #do:
	Receiver: a ZnCharacterReadStream
	Arguments and temporary variables: 
		aMessage: 	do: [ :each | table := table, each ]
		exception: 	Instance of ZnCharacterReadStream did not understand #do:
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a ZnBufferedReadStream
		encoder: 	a ZnUTF8Encoder
		peeked: 	nil


Program>>readTable
	Receiver: a Program
	Arguments and temporary variables: 
		table: 	''
		working: 	File @ /home/juanjoneri/UT/AdvancedAlgorithms/pp-jjn855/smalltalk/code...etc...
		stream: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		operation: 	'-print'
		argument: 	'0'
		tableFile: 	'../tests/1.txt'
		outFile: 	'../tests/0.out'


TableMain>>main:
	Receiver: a TableMain
	Arguments and temporary variables: 
		message: 	'-print 0 ../tests/1.txt ../tests/0.out'
		program: 	a Program
		table: 	nil
		tableName: 	nil
	Receiver's instance variables: 
a TableMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		a: 	a TableMain
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


OpalCompiler>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../test...etc...
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	a CompiledBlock: [ 
	result := Smalltalk compiler evaluate: aStream.
	...etc...
		numArgs: 	0
		receiver: 	an EvaluateCommandLineHandler


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../te...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImportCommandLineHandlers-Base'


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
		^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	a CompiledBlock: [ aCommandLinehandler activateWith: commandLine ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self handleArgument: self firstArgument ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | 
			"If the command line is protected by password, we ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ ...etc...
		startpc: 	a CompiledBlock: [ self handleArgument: self firstArgument ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the comma...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	a CompiledBlock: [ [ self handleArgument: self firstArgument ]
		on: E...etc...
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler



--- The full stack ---
ZnCharacterReadStream(Object)>>doesNotUnderstand: #do:
Program>>readTable
TableMain>>main:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
FullBlockClosure(BlockClosure)>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
FullBlockClosure(BlockClosure)>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
FullBlockClosure(BlockClosure)>>on:do:
[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
Processor in InputEventFetcher>>installEventLoop
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
TKTWorkerProcess>>privateNextTask
workerLoop

	[ self executeTask: self privateNextTask ] repeat in TKTWorkerProcess>>workerLoop
BlockClosure>>repeat
TKTWorkerProcess>>workerLoop
MessageSend>>value
arg1 in TKTPharoProcessProvider>>createProcessDoing:named:
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[  [runTimerEventLoop] whileTrue: 
		[	|nowTick|
			"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		 	ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay. 

			"Invoke the api back-ends, which set the transfer-variable to nil" 		
			suspendSemaphore ifNotNil: [ self suspendAtTimingPriority    ].
			delayToStart     ifNotNil: [ self scheduleAtTimingPriority   ].
			delayToStop      ifNotNil: [ self unscheduleAtTimingPriority ].

			"Signal any expired delays"
			nowTick := ticker nowTick.
			[ 	activeDelay notNil and: [nowTick >= activeDelay resumptionTick] ] 
					whileTrue: [
						activeDelay timingPrioritySignalExpired.
						activeDelay := suspendedDelays removeFirstOrNil ].
		]
	] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
FullBlockClosure(BlockClosure)>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
  stack:

[
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]] in CommandLineUIManager>>quitFrom:withMessage:
[
		logStream := self openLog.
		aMonadicBlock value: logStream.
	] in SmalltalkImage>>logDuring:
FullBlockClosure(BlockClosure)>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk 
		logError: aString
		inContext: aContext.
		
	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
FullBlockClosure(BlockClosure)>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
MessageNotUnderstood(Exception)>>unhandledErrorAction
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Exception)>>raiseUnhandledError
MessageNotUnderstood(Exception)>>defaultAction
------------------------------

THERE_BE_DRAGONS_HERE
Instance of ZnCharacterReadStream did not understand #do:
22 October 2021 5:22:59.024187 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
StackToRegisterMappingCogit * VMMaker-tonel.1 uuid: 6e75c100-768a-0d00-a503-de5f040b381d Oct 11 2021
v9.0.9 - Commit: 220ee65 - Date: 2021-10-11 15:53:10 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1564.sha.f5f541cb35c8609abfec418e35d5506715c7987d (64 Bit)]

ZnCharacterReadStream(Object)>>doesNotUnderstand: #do:
	Receiver: a ZnCharacterReadStream
	Arguments and temporary variables: 
		aMessage: 	do: [ :each | table := table, each ]
		exception: 	Instance of ZnCharacterReadStream did not understand #do:
		resumeValue: 	nil
	Receiver's instance variables: 
		stream: 	a ZnBufferedReadStream
		encoder: 	a ZnUTF8Encoder
		peeked: 	nil


Program>>readTable
	Receiver: a Program
	Arguments and temporary variables: 
		table: 	''
		working: 	File @ /home/juanjoneri/UT/AdvancedAlgorithms/pp-jjn855/smalltalk/code...etc...
		stream: 	a ZnCharacterReadStream
	Receiver's instance variables: 
		operation: 	'-print'
		argument: 	'0'
		tableFile: 	'../tests/1.txt'
		outFile: 	'../tests/0.out'


TableMain>>main:
	Receiver: a TableMain
	Arguments and temporary variables: 
		message: 	'-print 0 ../tests/1.txt ../tests/0.out'
		program: 	a Program
		table: 	nil
		tableName: 	nil
	Receiver's instance variables: 
a TableMain

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		a: 	a TableMain
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


OpalCompiler>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../test...etc...
	Receiver's instance variables: 
		ast: 	DoIt

	| a |
	a := TableMain new.
	^ a main: '-print 0 ../tests/1.txt ../t...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		startpc: 	a CompiledBlock: [ 
	result := Smalltalk compiler evaluate: aStream.
	...etc...
		numArgs: 	0
		receiver: 	an EvaluateCommandLineHandler


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../tests/0.o...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'|a|. a:=TableMain new. a main: ''-print 0 ../tests/1.txt ../te...etc...
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#activate...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImportCommandLineHandlers-Base'


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
		^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubComm...etc...
		startpc: 	a CompiledBlock: [ aCommandLinehandler activateWith: commandLine ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self handleArgument: self firstArgument ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit | 
			"If the command line is protected by password, we ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ ...etc...
		startpc: 	a CompiledBlock: [ self handleArgument: self firstArgument ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the comma...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		startpc: 	a CompiledBlock: [ [ self handleArgument: self firstArgument ]
		on: E...etc...
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler



--- The full stack ---
ZnCharacterReadStream(Object)>>doesNotUnderstand: #do:
Program>>readTable
TableMain>>main:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[ 
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [ 
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
FullBlockClosure(BlockClosure)>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
FullBlockClosure(BlockClosure)>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
FullBlockClosure(BlockClosure)>>on:do:
[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit | 
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in BasicCommandLineHandler>>activate
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
Processor in InputEventFetcher>>installEventLoop
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
TKTWorkerProcess>>privateNextTask
workerLoop

	[ self executeTask: self privateNextTask ] repeat in TKTWorkerProcess>>workerLoop
BlockClosure>>repeat
TKTWorkerProcess>>workerLoop
MessageSend>>value
arg1 in TKTPharoProcessProvider>>createProcessDoing:named:
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
------------------------------

Process: a Process in [delaySemaphore wait] in Delay>>wait
  stack:

[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[  [runTimerEventLoop] whileTrue: 
		[	|nowTick|
			"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		 	ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay. 

			"Invoke the api back-ends, which set the transfer-variable to nil" 		
			suspendSemaphore ifNotNil: [ self suspendAtTimingPriority    ].
			delayToStart     ifNotNil: [ self scheduleAtTimingPriority   ].
			delayToStop      ifNotNil: [ self unscheduleAtTimingPriority ].

			"Signal any expired delays"
			nowTick := ticker nowTick.
			[ 	activeDelay notNil and: [nowTick >= activeDelay resumptionTick] ] 
					whileTrue: [
						activeDelay timingPrioritySignalExpired.
						activeDelay := suspendedDelays removeFirstOrNil ].
		]
	] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
FullBlockClosure(BlockClosure)>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
  stack:

[
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>doTerminationFromYourself
  stack:

Process>>doTerminationFromYourself
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]] in CommandLineUIManager>>quitFrom:withMessage:
[
		logStream := self openLog.
		aMonadicBlock value: logStream.
	] in SmalltalkImage>>logDuring:
FullBlockClosure(BlockClosure)>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk 
		logError: aString
		inContext: aContext.
		
	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger | 
		logger nextPutAll: 'Processes and their stacks: ';cr.
		
		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.
		
			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.	
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
FullBlockClosure(BlockClosure)>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
MessageNotUnderstood(Exception)>>unhandledErrorAction
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Exception)>>raiseUnhandledError
MessageNotUnderstood(Exception)>>defaultAction
------------------------------

